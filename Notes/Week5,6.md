# 5, 6주차 (21. 11. 29)
[Notion Link](https://www.notion.so/5-6-21-11-29-bdf54dce705445cd85521cb852b76b89)

## 조명

조명의 입체감은 눈을 속이는 것의 필수적인 기술이다.

실제로 인간의 시각적 인식은 빛과 물체의 재질의 상호작용에 상당히 의존적이다.

실사적으로 느낀다 = 대부분이 물리적으로 정확한 조명 모형에 달려있는 경우가 많다.

PBR(Physical Based Rendering) 모델 - 물리적으로 옳은 것이 예쁘게 표현된다는 것은 아니다.

그러다보니 프로젝트 컨셉에 따라서 다른 모델을 쓰기도 한다.

### 국소 모형 vs 전역 모형

국소 모형 : 자기 자신만 생각한다. 나한테 빛이 왔고 반사가 되었다. 사람 눈으로 바로 들어간다 (계산할 필요가 없어서 빠르다)

전역 모형 : 직접광 뿐만 아니라 어떤 물체가 있고 빛이 반사되어서 해당 물체가 다시 반사하는 빛(간접광)을 모두 고려한다.

### Light Map

보통 Static Mesh, 움직이지 않는 것들은 구워 놓는 방식으로 진행한다.

### 표면 법선(surface normal)

조명을 계산하기 위해 삼각형 면의 수직이 되는 법선 벡터를 구한다.

**표면 법선** : 어떠한 점에 한해서 수직인 벡터

조명 계산을 하기 위해서는 점 하나하나에 대해서 계산할 것이므로 표면 법선이 필요하다.

그러나 모든 점에 대해서 구하는 경우 굉장한 낭비이다.

따라서 레스터라이저에게 이런 계산을 맡긴다 (면 법선을 구해서) p0 ~ p1까지 계산한다

![Untitled](https://user-images.githubusercontent.com/26589915/170847963-4b24f41d-bae7-4100-8667-97def7a42abf.png)

side1과 side2를 외적하면 수직인 벡터를 구할 수 있다.

### 정점 법선 평균 기법

조금 더 Mesh를 Smoth하게 바꿔준다.

임의의 다각형에서 계산할 때에는 모든 삼각형을 순회하고, 삼각형에 따라서 면 법선을 계산한 후, 정점에 저장된 법선들을 정규화하는 방식으로 계산한다.

### 법선 벡터의 변환

Scaling을 사용하게 되면 Normal Vector가 깨질 수 있다.

(Scaling을 하는 순간, 수직이 되지 않을 수 있다)

따라서 비례 변환을 할 때 Normal을 다시 수직으로 변환시키는 방법이 필요하다.

### 반사 벡터

어떤 물체의 빛이 튕겨서 우리 눈에 날라올 때 어떤 각도로 튕겨서 날아오는지 알 수 있기 위해 반사 벡터가 필요하다.

반사벡터 구하기는 면접 문제로도 자주 출제된다.

RGB값이 XYZ로 저장되어서 Mapping되어서 보여진다 (법선 벡터의 특성상 파랑이 많다)

Bump mapping : Rendering될 물체의 픽셀마다 표면 법선을 흔들어 높낮이가 있어보이게 하는 기법.

Specular Power : Specular에 얼마나 곱해줄 것인가를 의미한다.

### 람베르트 코사인 법칙

빛이 근사된다. 기울기에 따라 빛의 세기가 달라진다.

법선(노멀 벡터)의 입사각이 적을수록 세기가 크다.

cosine을 쓰는 이유는 윗변 / 빗변이기 때문이다.

![Screenshot_20211210-124947_Samsung_Notes](https://user-images.githubusercontent.com/26589915/170847952-684419cf-f353-41b7-8148-2c0edce28994.jpg)

### 분산 반사 Diffuse

빛이 부딪혔을 때 재질에 따라서 얼마나 반사되고 어떻게 날아가는가.

특정 재질에 따른 diffuse (해당 재질의 색상)를 지정해서 사용한다.

그냥 Lambert는 너무 어두워서 보통 Half-Lambert를 사용한다.

### 간접광 Ambient

빛이 튕겨서 주변을 비춘다. 그런 부분을 근사해서 보여주는 것이 간접광이다.

보통 개발자 입장에서는 아티스트들이 지정해주는 부분.

### 반영 반사 Specular

물체에 빛이 반사되어서 하얗게 보이는 곳. 보통 표현 방식으로는 Blinn과 Phong이 있다.

Phong과 같은 경우에는 반사각와 눈의 각도가 0에 가까울수록 밝아진다.

그러나 내적의 한계 때문에 끊겨 보이는 느낌이 난다

Phong의 각도 문제를 개선하기 위해 위해 Blinn Phong이 나왔다.

원래는 반사각과 시야각의 내적이 필요했으나 half-Vector를 구해서 Normal Vector와 내적을 해서 구한다. 이전에는 시야각과 Normal Vector를 내적해서 문제가 발생했기 때문이다.

## 조명 종류

Directional Light 태양 빛

태양은 굉장히 멀리 있기 때문에 일직선으로 내리쬔다고 가정한다.

가지는 속성은 방향 벡터 하나와 색상, 정도가 있다.

Point Light 전구

하나의 전구에서 빛이 사방으로 퍼져나간다. 위치값이 존재하며 빛이 거리에 따라서 약해진다.

Spot Light 손전등

일정 방향으로 퍼져나간다. 어떤 한 점에서 원기둥 형태로 뻐져나간다

형태를 구현하기 때문에 가장 무겁다.

Area Light

어떤 기하학 모형이던 조명으로 표현할 수 있다.

### 충돌체크

Phong : 반사 벡터와 View Direction을 내적한다. 180도를 넘어가는 순간 반사지수가 0이 된다.

Blinn-Phong : Phong과 동일하나 Half Vector와 Normal이랑 계산해서 180도 오류도 해결된다.

프레넬 효과Fresnel Effect : 모든 빛이 매질을 만났을 때에는 반사 / 흡수 / 굴절 등의 효과가 나타나는데 이 과정에서 매질마다 갖는 반사 / 흡수 / 굴절률이 다르다.

## Texture

Texel : 픽셀은 스크린의 해상도에 1:1로 대응되는 단위. 즉, 텍셀은 텍스처 공간의 단위.

DDS : png나 jpeg와 같은 이미지 포맷 형식. DXT1-DXT5를 썼을 때 압축 해제 없이 GPU에 바로 올릴수 있다는 장점이 있다. 또한 Mipmap을 저장할 수 있다

Image Filter : UV가 넘어갔을 때 어떻게 처리할 것인지 옵션(WRAP, CLMAP 등)을 설정 가능.